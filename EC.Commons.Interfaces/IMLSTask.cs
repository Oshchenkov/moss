using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace EC.Common.Interfaces
{
    /// <summary>
    /// Base interface for various flavours of wrappers around the underlying C# Task.
    /// </summary>
    
    public interface IMLSTask
    {
        /// <summary>
        /// Give the task some code to execute.
        /// </summary>
        /// <param name="a">the code for the task to execute</param>
        
        void Execute(Action a);

        /// <summary>
        /// Return the task's status.
        /// </summary>
        /// <returns>task status</returns>
        
        TaskStatus Status();

        /// <summary>
        /// Block until this task completes.
        /// </summary>

        void Wait();

        /// <summary>
        /// Return the underlying C# Task.
        /// </summary>

        Task GetUnderlyingTask();

        /// <summary>
        /// If true, then any exceptions generated by this task will be caught and logged
        /// within the task, but not re-thrown. If false, then exceptions will be available
        /// via Wait(). Default value is false.
        /// </summary>
        
        bool SwallowExceptions { get; set; }
    }

    /// <summary>
    /// SyncTask is used to spawn a background action and then wait for it to complete.
    /// </summary>
    /// <remarks>
    /// It may seem pointless to spawn a background task only to sit and wait for it to 
    /// complete. However, this is exactly the interaction required if you want to 
    /// create a new unit of work that is independent of the one you are currently
    /// executing in.
    /// </remarks>

    public interface ISyncTask : IDisposable, IMLSTask
    {
    }

    /// <summary>
    /// TaskWithContext allows a task to be spawned that relies on IRequestContext (which almost
    /// all service level code does). It uses the RequestContext of the thread spawning the
    /// task. A thread which creates a TaskWithContext cannot exit/complete until the TaskWithContext
    /// is complete.
    /// </summary>
    
    public interface ITaskWithContext : IMLSTask
    {
    }

    /// <summary>
    /// Interface for services that apply to groups of tasks.
    /// </summary>
    
    public interface IMLSTaskServices
    {
        /// <summary>
        /// Wait for all tasks to complete. This is a wrapper around Task.WaitAll(). If
        /// any of the tasks throw an exception, WaitAll() throws an AggregateException.
        /// </summary>
        /// <param name="tasks">array of tasks to wait for</param>
        
        void WaitAll(IMLSTask[] tasks);

        /// <summary>
        /// Wait for all the given tasks to complete, and then extract any exceptions from the
        /// tasks. The first exception is re-thrown; others are just logged.
        /// </summary>
        /// <param name="tasks">array of IMLSTasks to wait for</param>

        void WaitAllAndThrowException(IMLSTask[] tasks);
    }
}
